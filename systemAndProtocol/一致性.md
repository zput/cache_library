

- 「一致性」有关的至少有两个词：consistency和consensus。它们经常都被翻译成「一致性」，这进一步加剧了这个概念被滥用的程度。为了接下来讨论方便，我们先简单地澄清一下：
  - 网上通常提到的诸如Paxos之类的分布式一致性协议，其实是consensus这个词。它如果被翻译成「共识」，可能会更好一些。为了表达清晰，本文后面在讨论consensus问题的时候，尽量使用「共识」这个词。
  - ACID或CAP里C，用的都是consistency这个词，但真实含义迥然不同。
  - 此外，还经常会听到人们关于「强一致性」的说法，而且这种说法通常都会牵涉到CAP定理或者「分布式事务」的概念。「强一致性」与CAP定理确实关系密切，但与「分布式事务」的关系却不知从何而来。

- 共识问题（consensus problem）
  - what:
    - 解决的是如何在分布式系统中的**多个节点**之间就某个提议达成共识。它**只关注**没有发生故障的节点达成共识就可以了。
    - 在分布式事务中，ACID中的原子性，引出了原子提交问题，它解决的是参与分布式事务的所有节点在“执行Commit还是Abort”这一点上达成共识。
      - 原子提交问题属于uniform consensus问题，要求**所有节点（包括故障节点）都要达成共识**，是比consensus问题更难的一类问题。
  - why:
  - how:
    - Paxos和解决拜占庭将军问题的算法，解决的是consensus问题；
    - 2PC/3PC，解决的是一个特定的uniform consensus问题。



- ACID
  - what:
    - ~~(atomicly, consisten, isolution, duration)~~
    - 原子性 (Atomicity)、一致性 (Consistency)、隔离性 (Isolation)和持久性 (Durability)
      - **原子性、隔离性和持久性，都是数据库本身所提供的技术特性;而一致性，则是由特定的业务场景规定的**. 怪不得《Designing Data-Intensive Applications》[1]一书的作者在书中写道：“The letter C doesn’t really belong in ACID”。
        - consistency:
          - ACID中的一致性，是个很偏应用层的概念。一致性，是由业务层决定的.(银行业务：转账前后账户总额保持不变)
            - 它指的是任何**一个数据库事务**的执行，都应该让**整个数据库保持在「一致」的状态**。那怎样的状态才算「一致」呢？举个例子，假设在银行账户之间进行转账。显然，「转账」这个操作应该确保在转账前后账户总额保持不变，这是任何一个转账操作必须要遵守的规定。现在假设要从账户A向账户B转账100元，于是我们启动了一个数据库事务。在这个事务中，可以先从账号A中减去100元，再往账户B中增加100元。这样的一个事务操作，满足了“转账前后账户总额保持不变”的规定，因此我们说：这个事务操作保持了数据库的「一致性」；同时，在这个事务执行前后，数据库都处于一种「一致」的状态。
              - ACID中的「一致性」，是对于整个数据库的「一致」状态的维持。
                - 抽象来看，对数据库每进行一次事务操作，它的状态就发生一次变化。这相当于把数据库看成了状态机，只要数据库的起始状态是「一致」的，并且每次事务操作都能保持「一致性」，那么数据库就能始终保持在「一致」的状态上 (Consistency Preservation)。
              - 所谓状态是不是「一致」，其实是由业务层规定的。
                - 比如前面这个转账的例子，“转账前后账户总额保持不变”，这个规定只对于「转账」这个特定的业务场景有效。如果换一个业务场景，「一致」的概念就不是这样规定了。所以说，ACID中的「一致性」，其实是体现了业务逻辑上的合理性，并不是由数据库本身的技术特性所决定的。
  - why:
    - 为了让数据库稳健？
  - how:
    - 避免错误和防止并发: ```数据库的原子性和隔离性的（应对错误和并发）+ 应用层对于事务本身的实现逻辑是正确无误```
      - **错误**:
        - 第一类，事务本身的实现逻辑可能存在错误。
          - 比如，从账户A向账户B转账100元，在这个事务中，如果我们只从账号A中减去了100元，但忘记了往账户B中增加100元，那么这个事务就是错误的。显然，避免第一类错误，是保持一致性的前提，这需要应用层进行恰当的编码来保证。
        - 第二类，则是意想不到的各种软硬件错误。**需要ACID中的A（原子性）来保障。**
          - 比如，还是从账户A向账户B转账100元，事务本身的实现逻辑没有问题，它先执行了从账号A中减去了100元，但在执行往账户B中增加100元之前，却发生了意想不到的错误，比如进程突然crash了，或是磁盘满了，或是网络突然不通了，或是其它任何可能的硬件错误。这时候，事务只执行了前一半，势必会破坏数据库整体状态的一致性。那怎么办呢？这其实就需要ACID中的A（原子性）来保障了。简言之，原子性保障了事务的执行要么全部成功，要么全部失败，而不允许出现“只执行了一半”这种“部分成功”的情况。
      - **并发**：
        - 这就需要ACID中的I（隔离性）来保障。
          - 什么是隔离性呢？它对于并发执行的多个事务进行合理的排序，保障了不同事务的执行互不干扰。换言之，隔离性这种特性，能够让并发执行的多个事务就好像是按照「先后顺序」执行的一样。



- CAP
  - what:
    - 一致性（Consistency）、可用性（Availability）和分区容错性（Partition-tolerance）
      - 对于一个分布式存储系统来说，线性一致性的含义可以用一个具体的描述来取代：**对于任何一个数据对象来说，系统表现得就像它只有一个副本一样[1]。**“表现得像只有一个副本”，也就相当于满足了前面的「合法」条件。
  - why:
    - 任何一个分布式系统只能同时满足三个特性中的两个?
      - 如果系统对于每个数据对象真的只存一个副本，那么肯定是满足线性一致性的。但是**单一副本不具有容错性**，
        - 所以分布式存储系统一般都会对数据进行复制（replication），也就是保存多个副本, 这时，在一个分布式多副本的存储系统中，要提供线性一致性的保证，就需要付出额外的成本了。
          - 所以导致不能满足**可用性（Availability）**?
  - how:


- 分布式系统，无非是因为分布式系统能带来一些「好处」，比如容错性、可扩展性等等。为了获得这些「好处」，分布式系统实现上常用的方法是复制 (replication) 和分片 (sharding)。
  - 容错 (fault tolerance): 即使某些网络节点发生故障，由于原本保存着在故障节点上的数据在正常节点上还有备份，所以整个系统仍然可能是可用的。这也是我们期待分布式系统能够提供的「高可用」特性。
  - 提升吞吐量: 将一份数据复制多份并保存在多个副本节点上，还顺便带来一个好处：对于同一个数据对象的访问请求（至少是读请求）可以由多个副本节点分担，从而使得整个系统可以随着请求量的增加不断扩展。
- 带来了很多挑战，其中最重要的一个就是数据的一致性问题。由于同一份数据保存在了多个副本节点上，它们之间就存在数据不一致的风险。我们当然希望同一份数据的不同副本总是保持一致。换句话说，我们希望在其中一个副本上所做的修改，在其它副本上也能随时观察到（即读取到）

- 顺序一致性的英文是：sequential consistency。
  - 顺序一致性定义[3,4]：如果一个并发执行过程所包含的所有读写操作能够重排成一个全局线性有序的序列，并且这个序列满足以下两个条件，那么这个并发执行过程就是满足顺序一致性的：
    - 条件I：重排后的序列中每一个读操作返回的值，必须等于前面对同一个数据对象的最近一次写操作所写入的值。
    - 条件II：原来每个进程中各个操作的执行先后顺序，在这个重排后的序列中必须保持一致。
- 线性一致性的英文是：linearizability。实际上，它就是CAP定理中的C，我们在上一篇文章中已经提到过。
  - 线性一致性的定义[5]，与顺序一致性非常相似，也是试图把所有读写操作重排成一个全局线性有序的序列，但除了满足前面的条件I和条件II之外，还要同时满足一个条件：
    - 条件III：不同进程的操作，如果在时间上不重叠，那么它们的执行先后顺序，在这个重排后的序列中必须保持一致。




最终一致性的英文是：eventual consistency。

http://zhangtielei.com/posts/blog-distributed-strong-weak-consistency.html















