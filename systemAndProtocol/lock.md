
<!-- @import "[TOC]" {cmd="toc" depthFrom=1 depthTo=6 orderedList=false} -->

<!-- code_chunk_output -->

- [锁](#锁)
  - [互斥锁(Mutual exclusion，缩写Muex)](#互斥锁mutual-exclusion缩写muex)
  - [自旋锁：](#自旋锁)
    - [互斥和自旋比较](#互斥和自旋比较)
  - [读写锁](#读写锁)
  - [悲观锁 （读写锁，自旋锁，互斥锁都是悲观锁）](#悲观锁-读写锁自旋锁互斥锁都是悲观锁)
  - [乐观锁：](#乐观锁)

<!-- /code_chunk_output -->
## 锁

  - what：是锁住一种资源，操作这个资源的时候必须先获得它的锁，然后操作，释放。
  - why：并发的时候，可能两个进程或线程操作同一个数据，如果没有锁，就会导致数据的混乱。


### 互斥锁(Mutual exclusion，缩写Muex)

  - what：它是独占锁，当一个线程加锁后，其他线程加锁就会失败，只能释放CPU，从而阻塞（没有CPU了，肯定阻塞）
  - why：对用户来说简单，当加锁失败，内核会自动切换睡眠。
  - how: 通过系统内核来实现，当加锁失败，释放CPU，进行了上下文的切换。

### 自旋锁：

  - what：通过CPU提供的CAS函数，在用户态完成加锁，解锁过程，不会产生上下文切换。
  - why：没有上下文切换，可以忙等待【通过while条件，或CPU pause指令】
  - how：原子性的，要么都成功，要么都失败。
    - 查看锁的状态，如果状态等于old status，用new status替代。

#### 互斥和自旋比较

  - 当加锁失败，互斥是上下文切换睡眠，而自旋是一个while判断，所以要看被锁住的代码执行时间。
    - 当代码执行时间很短，那么上一个获得锁的线程执行的也短，所以自旋的while等待的时间或次数也很短，此时不用上下文切换就是很好。

### 读写锁

  - what：
    - 写锁是独占锁，任何时候只能有一个线程持有写锁，类似上面的互斥锁，自旋锁。
    - 读锁是共享锁，可以被多个线程同时持有
  - why：当读多写少的场景能发挥出优势。
  - how：
   - 读优先锁：
     - 当有读的线程来，即使前面有写锁获取锁失败睡眠，但是还是这个读优先读
       - 造成写饥饿。
   - 写优先锁：
     - 当写锁获取锁失败睡眠，它后面来的线程读锁也会失败。
       - 如果写的操作过多，那么并发性就不是很好。

### 悲观锁 （读写锁，自旋锁，互斥锁都是悲观锁）

  - what：【冲突的概率高】总是悲观的认为会并发修改资源的概率高，防止冲突，所以必须先加锁，
  - ...
  - how：使用读写锁，自旋锁，互斥锁。

### 乐观锁：

  - what：【无锁的，乐观锁是无锁的。冲突的概率低】总是乐观的认为别人不会改，于是自己先改，然后再验证是否有冲突。
  - why：
  - how：因为发生冲突，重试的成本高；所以只有在冲突概率低，且加锁的成本高才使用乐观锁。
    - 验证冲突，可以使用版本的概念。version，当前修改的版本低，那么证明已经被别人修改了。

- 使用锁：
  - 加锁代码范围应该尽可能小，
  - 使用合适的锁。



分类 | 方案 | 实现原理 | 优点 | 缺点
---|----|------|----|---
基于数据库 | 基于mysql 表唯一索引 | 1.表增加唯一索引  2.加锁：执行insert语句，若报错，则表明加锁失败 3.解锁：执行delete语句 | 完全利用DB现有能力，实现简单 | 1.锁无超时自动失效机制，有死锁风险 2.不支持锁重入，不支持阻塞等待 3.操作数据库开销大，性能不高
| | 基于MongoDB findAndModify原子操作 | 1.加锁：执行findAndModify原子命令查找document，若不存在则新增 2.解锁：删除document | 实现也很容易，较基于MySQL唯一索引的方案，性能要好很多 | 1.大部分公司数据库用MySQL，可能缺乏相应的MongoDB运维、开发人员 2.锁无超时自动失效机制
基于分布式协调系统 | 基于ZooKeeper | 1.加锁：在/lock目录下创建临时有序节点，判断创建的节点序号是否最小。若是，则表示获取到锁；否，则则watch /lock目录下序号比自身小的前一个节点     2.解锁：删除节点 | 1.由zk保障系统高可用 2.Curator框架已原生支持系列分布式锁命令，使用简单 | 需单独维护一套zk集群，维保成本高
基于缓存 | 基于redis命令 | 1. 加锁：执行setnx，若成功再执行expire添加过期时间   2. 解锁：执行delete命令 | 实现简单，相比数据库和分布式系统的实现，该方案最轻，性能最好 | 1.setnx和expire分2步执行，非原子操作；若setnx执行成功，但expire执行失败，就可能出现死锁    2.delete命令存在误删除非当前线程持有的锁的可能   3.不支持阻塞等待、不可重入 
| | 基于redis Lua脚本能力 | 1. 加锁：执行```SET lock_name random_value EX seconds NX```命令   2. 解锁：执行Lua脚本，释放锁时验证```random_value``` **下面的lua脚本。** | 同上；实现逻辑上也更严谨，除了单点问题，生产环境采用用这种方案，问题也不大。 | 不支持锁重入，不支持阻塞等待


```lua
-- ARGV[1]为random_value, | KEYS[1]为lock_name
if redis.call("get", KEYS[1]) == ARGV[1] 
then
    return redis.call("del",KEYS[1])
else
    return 0
end
```

https://blog.csdn.net/asd051377305/article/details/108384490

https://redis.io/commands/set

https://github.com/redisson/redisson










