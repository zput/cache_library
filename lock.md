
- 锁
 - what：是锁住一种资源，操作这个资源的时候必须先获得它的锁，然后操作，释放。
 - why：并发的时候，可能两个进程或线程操作同一个数据，如果没有锁，就会导致数据的混乱。


- 互斥锁(Mutual exclusion，缩写Muex)
  - what：它是独占锁，当一个线程加锁后，其他线程加锁就会失败，只能释放CPU，从而阻塞（没有CPU了，肯定阻塞）
  - why：对用户来说简单，当加锁失败，内核会自动切换睡眠。
  - how: 通过系统内核来实现，当加锁失败，释放CPU，进行了上下文的切换。

- 自旋锁：
  - what：通过CPU提供的CAS函数，在用户态完成加锁，解锁过程，不会产生上下文切换。
  - why：没有上下文切换，可以忙等待【通过while条件，或CPU pause指令】
  - how：原子性的，要么都成功，要么都失败。
    - 查看锁的状态，如果状态等于old status，用new status替代。

- 互斥和自旋比较
  - 当加锁失败，互斥是上下文切换睡眠，而自旋是一个while判断，所以要看被锁住的代码执行时间。
    - 当代码执行时间很短，那么上一个获得锁的线程执行的也短，所以自旋的while等待的时间或次数也很短，此时不用上下文切换就是很好。


- 读写锁
 - what：
   - 写锁是独占锁，任何时候只能有一个线程持有写锁，类似上面的互斥锁，自旋锁。
   - 读锁是共享锁，可以被多个线程同时持有
 - why：当读多写少的场景能发挥出优势。
 - how：
  - 读优先锁：
    - 当有读的线程来，即使前面有写锁获取锁失败睡眠，但是还是这个读优先读
      - 造成写饥饿。
  - 写优先锁：
    - 当写锁获取锁失败睡眠，它后面来的线程读锁也会失败。
      - 如果写的操作过多，那么并发性就不是很好。


- 悲观锁 （读写锁，自旋锁，互斥锁都是悲观锁）
  - what：【冲突的概率高】总是悲观的认为会并发修改资源的概率高，防止冲突，所以必须先加锁，
  - 
  - how：使用读写锁，自旋锁，互斥锁。

- 乐观锁：
  - what：【无锁的，乐观锁是无锁的。冲突的概率低】总是乐观的认为别人不会改，于是自己先改，然后再验证是否有冲突。
  - why：
  - how：因为发生冲突，重试的成本高；所以只有在冲突概率低，且加锁的成本高才使用乐观锁。
    - 验证冲突，可以使用版本的概念。version，当前修改的版本低，那么证明已经被别人修改了。


- 使用锁：
  - 加锁代码范围应该尽可能小，
  - 使用合适的锁。



