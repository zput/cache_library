# 0.重要的知识点

1. MySQL逻辑架构
  1.1. 连接层
  1.2. 服务层
  1.3. 引擎层(存储引擎是基于表的，而不是数据库)
  1.4. 存储层

2. 如何修改字符集(查看1.3)

3. 日志
  3.1. 查询日志
  3.2. 错误日志
  3.3. 二进制日志

- 4. 分析慢SQL的步骤
  - ~~first:找到是那些sql慢.~~
    - 4.1. 慢查询的开启，设置阈值(如超过5秒钟的就是慢SQL)并捕获。
  - ~~second:开始分析这些sql.~~
    - 4.2. explain + 慢SQL分析。
      - 查询语句写的差。
        - 关联 查询太多`join`（设计缺陷或者不得已的需求）。
      - 索引失效：索引建了，但是没有用上。
    - 4.3. show Profile查询SQL在MySQL数据库中的执行细节和生命周期情况。
    - 4.4. MySQL数据库服务器的参数调优。

5. SQL执行顺序

```shell
select              # 5 ---->
	... 
from                # 1
	... 
where               # 2
	.... 
group by            # 3
	... 
having              # 4 ---->
	... 
order by            # 6
	... 
limit               # 7
	[offset]
```

6. join
![如何写出join语句](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201203160509.png)


- 7. 索引
  - what: [A database index is a data structure that improves the speed of operations in a table](https://www.tutorialspoint.com/mysql/mysql-indexes.htm)
    - 索引分类：
      - 单值索引：一个索引只包含单个列，一个表可以有多个单列索引。
      - 唯一索引：索引列的值必须唯一，但是允许**空值**。
      - 复合索引：一个索引包含多个字段。
  - why:
    - 索引的优势和劣势
      - 优势：
        - 查找：类似大学图书馆的书目索引，提高数据检索的效率，降低数据库的IO成本。
        - 排序：通过索引対数据进行排序，降低数据排序的成本，降低了CPU的消耗。
      - 劣势：
        - 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的。
        - 虽然索引大大提高了查询速度，但是同时会降低表的更新速度，例如对表频繁的进行`INSERT`、`UPDATE`和`DELETE`。因为更新表的时候，MySQL不仅要保存数据，还要保存一下索引文件每次更新添加的索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。
        - 索引只是提高效率的一个因素，如果MySQL有大数据量的表，就需要花时间研究建立最优秀的索引。

  - how: 
    - **重点：索引会影响到MySQL查找(WHERE的查询条件)和排序(ORDER BY)两大功能！**
    - 什么时候需要建立索引：
      - 主键:主键自动建立主键索引（唯一 + 非空）。
      - where/order by:
        - 频繁作为查询条件的字段应该创建索引。
        - 查询中统计或者分组字段（group by也和索引有关）。
        - 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度。
      - 查询中与其他表关联的字段，**外键关系**建立索引。
    - 索引分析
      - 从9.1.单表索引分析-->范围之后的索引会失效。
      - 从9.2.两表索引分析--->左连接将索引创建在右表上更合适。
      - 10.1.索引失效的情况:
        - 全值匹配我最爱。
        - 最佳左前缀法则。
        - 不在**索引列**上做任何操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描。
        - 索引中**范围条件**右边的字段会全部失效。
        - 尽量使用覆盖索引（只访问索引的查询，索引列和查询列一致），减少`SELECT *`。
        - MySQL在使用`!=`或者`<>`的时候无法使用索引会导致全表扫描。
        - `is null`、`is not null`也无法使用索引。
        - `like`以通配符开头`%abc`索引失效会变成全表扫描。
        - 字符串不加单引号索引失效。
        - 少用`or`，用它来连接时会索引失效。

- 8. 锁
  - InnoDB锁:
    - 1. 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
    - 2. 排他锁（X）：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。
    >为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB 还有两种内部使用的意向锁（Intention Locks），这两种意向锁都是表锁：
    - 3. 意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的 IS 锁。
    - 4. 意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的 IX 锁。

![20201204193446](https://raw.githubusercontent.com/zput/myPicLib/master/zput.github.io/20201204193446.png)

>>（如果一个事务请求的锁模式与当前的锁兼容， InnoDB 就将请求的锁授予该事务； 反之， 如果两者不兼容，该事务就要等待锁释放。）

  - InnoDB加锁方法：
    - 对于普通```SELECT```语句，InnoDB 不会加**任何锁**；
    - 对于 ```UPDATE、 DELETE 和 INSERT``` 语句， InnoDB会自动给涉及数据集加**排他锁（X)**；
    - 事务可以通过以下语句显式给记录集加共享锁或排他锁：
      - 共享锁（S）：```SELECT * FROM table_name WHERE ... LOCK IN SHARE MODE```。 其他 session 仍然可以查询记录，并也可以对该记录加 share mode 的共享锁。但是如果当前事务需要对该记录进行更新操作，则很有可能造成死锁。
      - 排他锁（X)：```SELECT * FROM table_name WHERE ... FOR UPDATE```。其他 session 可以查询该记录，但是不能对该记录加共享锁或排他锁，而是等待获得锁
    - ~~意向锁是 InnoDB 自动加的， 不需用户干预。~~
